
<!-- README.md is generated from README.Rmd. Please edit that file -->

# SilviMetric Testing

**Testing uses the pixel_is_point branch from the [SilviMetric
repo](https://github.com/hobuinc/silvimetric) (v1.3.1). This branch
implements two raster alignment methods that apply to the entire TileDB.
The methods are: ‘PixelIsPoint’ and ‘PixelIsArea’ for a change. FUSION
uses the ‘PixelIsPoint’ alignment so raster cell centers are aligned to
a multiple of the cell size. The ‘PixelIsCell’ option aligns cell edges
to a multiple of the cell size. The main branch in the repo uses and
alignment such that the cell edges fall on a multiple of the cell
size.**

The pixel_is_point branch will, ultimately, be merged into the main
branch of SilviMetric.

## Example lidar data

Test data is from USGS collection covering the Plumas National Forest In
CA. These data have outliers classified as 7 & 18 and outliers marked as
overlap points but not as outliers (bad outlier classification). In
addition, there are good points marked as overlap that were used in the
FUSION processing.

One scenario is to drop all overlap points but this will drop lots of
good points and outputs won’t match FUSION outputs. FUSION filters
points by classification and height so the best solution would be to use
outlier filtering based on classification and height filtering after
computing HAG to the pipeline used to pump data into SilviMetric.

Ground models for the area were derived from class 2 points in a FUSION
run.

Raster resolution for testing is 30m.

## Python code for running SilviMetric

Code is is the Python directory and uses the SilviMetric API.

Test workflows rely on data on a local computer (paths are hard coded).
While this makes it nearly impossible for someone else to run the code
as-is, it doesn’t negate the utility of the code to learn how to do
simple processing.

The testing code is very fluid so expect changes and additional
workflows as testing proceeds.

The basic workflow
([workflow1.py](https://github.com/bmcgaughey1/SilviMetricTesting/blob/24fba55ed3d666b5fc83bb925c61ef3f37c61a8e/Python/workflow1.py))
is as follows: \* creates a GDAL VRT using DEM tiles created in a FUSION
run (1m resolution) \* scan a set of point tiles to get overall extent
\* define set of metrics to compute \* create storage (create Tiledb
structure) \* iterate through tiles + build PDAL pipeline to supply
point data from the tile + get tile extent + scan the tile to determine
tile size for shatter + shatter tile to compute metrics \* extract
metrics to raster files

The VRT is used to compute height above ground (HAG) for point data fed
to SilviMetric. Any GDAL-readable format can be used to build the VRT.
The most common scenario would be to use vendor-delivered DEM tiles. In
the testing, I used DEMs generated by a FUSION run. Not that these tiles
do not correspond to the point tiles.

The PDAL pipeline (through the build_pipeline function in smhelper.py)
can filter using point classification values, point flags, and HAG. It
can also deal with point data reprojection (not used in testing). For
testing, the Z dimension was replaced by HAG (option when building the
pipeline).

The testing code
([workflow1.py](https://github.com/bmcgaughey1/SilviMetricTesting/blob/24fba55ed3d666b5fc83bb925c61ef3f37c61a8e/Python/workflow1.py))
offers alternative methods for computing HAG. These were used to
generate metrics for comparison with FUSION outputs. In general, using a
VRT will produce the cleanest HAG values. Other options, hag_delaunay
and hag_nn, rely on ground points in each cell when computing HAG. Some
cells will have few points or the distribution of ground point in some
cells will not be uniform. Both of these conditions will result in
values for HAG that don’t match those computed using a full-coverage
DEM.

I also expect slight differences when using the VRT compared to HAG
computed by FUSION. FUSION uses bilinear interpolation when deriving
ground elevations for points and (I think) PDAL uses the value of the
DEM cell that contains the point. Given the high resolution typical with
lidar-derived DEMs, this will produce small differences. However, some
point cloud data (e.g. DAP data from NAIP imagery) will not have
accompanying DEMs. For such data, we have relied on either lidar-derived
DEMs (best case) or other DEM source with coarser resolutions (10+m).

There is another workflow that produces a 1.5m resolution canopy height
model (CHM) using SilviMetric. This is a capability that was not really
part of SilviMetric’s scope but it does produce a useable product.
Probably not the most efficient way to produce a CHM but useable.

**SilviMetric crashed when using hag_delaunay to compute HAG so this
method was not included in testing.**

[smhelpers.py](https://github.com/bmcgaughey1/SilviMetricTesting/blob/24fba55ed3d666b5fc83bb925c61ef3f37c61a8e/Python/smhelpers.py)
contains functions used to develop the workflows. This code should be
useful to others wanting to apply SilviMetric to their data:

- scan_asset_for_bounds()
- scan_for_bounds()
- scan_for_srs()
- build_pipeline()
- write_pipeline()
- transform_bounds()

**Documentation for these functions will be added later…**

## R code for comparing SilviMetric outputs to FUSION outputs

The python code mentioned above produces a limited set of metrics (min.
max, mean and P75). However, they are sufficient to test the alignment
and values relative to outputs from FUSION. FUSION typically adds an
extra row and column of NODATA cells to its raster outputs. This is an
artifact of conservative bounds used in GridMetrics. The extra row and
column are on the top and right edges of the raster outputs. While this
doesn’t usually cause problems using the outputs, it makes direct
comparison of SilviMetric and FUSION outputs a bit challenging.

To deal with the different extents produced by FUSION and SilviMetric, I
developed code in R using the terra package that manipulates the outputs
to force the same extent. As with the python code, the R code uses local
computer paths containing FUSION and SilviMetric outputs.

R code is in the Rcode folder and is presented using RMarkdown rendered
to PDF format. To review the comparison results, look at the PDF
documents in the Rcode folder.

## Results

I compared several metric outputs and found differences that are mostly
related to the method used to construct the DEM used to compute HAG.
When running SilviMetric using point data normalized by FUSION,
differences are very small and I think the differences are due to the
set of points used for the cells. FUSION omits points on the right and
top edges of cells but SilviMetric (PDAL) includes these points.

I also compared a 1.5m CHM built in a separate run of SilviMetric using
all points with HAG \>= 0.0. This comparison is a little wonky because
FUSION fills “holes” in the CHM using bilinear interpolation and
SilviMetric does not (this would best be a post-processing step using
the SilviMetric CHM). This behavior can be controlled in FUSION.

[results](https://github.com/bmcgaughey1/SilviMetricTesting/blob/f2fe47e20f8910a1aeb0b393639841acf73b431c/Rcode/MetricComparison.pdf)
